# Kubernetes

> Kubernetes Cheat Sheet for Developers

<details>
<summary>
<b>Popular</b>
</summary>

```bash
# Ger logs of Pods in a Deployment. This is the recommended way to fetch logs, as the deployment name remains the same even if pods change upon creation.
kubectl logs deploy/<deployment-name>

# View the latest logs from the end. This can be useful when there are a large number of logs generated by a pod.
kubectl logs deploy/<deployment-name> --tail=2000

# Access a Pod within a Deployment using an interactive bash shell. This is the recommended method as the deployment name remains the same, unlike the pods that change upon creation.
kubectl exec -it deploy/<deployment-name> -- bash

# Access a Pod within a Deployment using an interactive shell. Use this if the previous method fails, as the pod does not support bash.
kubectl exec -it deploy/<deployment-name> -- sh

# Apply a folder or file containing Kubernetes manifests.
kubectl apply -f <folder-name-or-filename>

# Delete a folder or file containing Kubernetes manifests.
kubectl delete -f <folder-name-or-filename>

# Delete a deployment.
kubectl delete deployment <deployment-name>

# Forcefully delete a deployment without waiting for graceful termination.
kubectl delete deployment <deployment-name> --grace-period=0 --force

# Display the logs of a specific pod.
kubectl logs <pod-name>

# Stream and display the logs of a specific pod.
kubectl logs <pod-name> --follow

# Delete all jobs.
kubectl delete jobs `kubectl get jobs -o custom-columns=:.name`

# Delete pods based on a selector.
kubectl delete pods -l <pod-selector-key>=<pod-selector-value>
```
</details>

<details>
<summary>
<b>Pods</b>
- Pods are the fundamental compute unit in Kubernetes. A Pod is analogous to a container but with some key differences. Pods can contain multiple containers, each of which share a context. The entire Pod will always be scheduled onto the same node. The containers within a Pod are tightly coupled so you should create a new Pod for each distinct part of your application, such as its API and database.In simple situations, Pods will usually map one-to-one with the containers your application runs. In more advanced cases, Pods can be enhanced with init containers and ephemeral containers to customize startup behavior and provide detailed debugging.
</summary>

```bash
# List all pods in the current namespace.
kubectl get pods

# Get detailed information about a pod.
kubectl describe pod <pod-name>

# Create a new pod.
kubectl create pod <pod-name>

# Delete a pod.
kubectl delete pod <pod-name>
```
</details>

<details>
<summary>
<b>Nodes</b>
- Nodes represent the physical machines that form your Kubernetes cluster. They run the containers you create. Kubernetes tracks the status of your nodes and exposes each one as an object. You used Kubectl to retrieve a list of nodes in the example above.
</summary>

```bash
# List all nodes in the cluster.
kubectl get nodes

# Get detailed information about a node.
kubectl describe node <node-name>

# Create a new node
kubectl create node <node-name>

# Delete a node
kubectl delete node <node-name>
```

</details>

<details>
<summary>
<b>Services</b>
- Services are used to expose Pods to the network. They allow defined access to Pods either within your cluster or externally.
</summary>
    
```bash
# List all services in the cluster.
kubectl get services

# Get detailed information about a service.

kubectl describe service <service-name>

# Create a new service.

kubectl create service <service-name>

# Delete a service.

kubectl delete service <service-name>
```
</details>

<details>
<summary>
<b>Deployments</b>
- Deployments wrap ReplicaSets with support for declarative updates and rollbacks. They’re a higher level of abstraction that’s easier to control.A Deployment object lets you specify the desired state of a set of Pods. This includes the number of replicas to run. Modifying the Deployment will automatically detect the required changes and scale the ReplicaSet as required. You can pause the rollout or revert to an earlier revision, features that aren’t available with plain ReplicaSets.
</summary>

```bash
# List all deployments in the cluster.
kubectl get deployments 

# Get detailed information about a deployment.
kubectl describe deployment <deployment-name> 

# Create a new deployment.
kubectl create deployment <deployment-name> 

# Delete a deployment.
kubectl delete deployment <deployment-name> 
```
</details>


<details>
<summary>
<b>Replicasets</b>
- ReplicaSets are used to consistently replicate a Pod. They provide a guarantee that a set number of replicas will be running at any time. If a node goes offline or a Pod becomes unhealthy, Kubernetes will automatically schedule a new Pod instance to maintain the specified replica count.
</summary>

```bash
# List all replica sets in the cluster.
kubectl get replicasets 

# Get detailed information about a replica set.
kubectl describe replicaset <replicaset-name> 

# Create a new replica set.
kubectl create replicaset <replicaset-name> 

# Delete a replica set.
kubectl delete replicaset <replicaset-name> 
```
</details>


<details>
<summary>
<b>Statefulset</b>
</summary>

```bash
# List all stateful sets in the cluster.
kubectl get statefulsets 

# Get detailed information about a stateful set.
kubectl describe statefulset <statefulset-name> 

# Create a new stateful set.
kubectl create statefulset <statefulset-name> 

# Delete a stateful set.
kubectl delete statefulset <statefulset-name> 
```
</details>

<details>
<summary>
<b>Jobs</b>
- A Kubernetes Job is an object that creates a set of Pods and waits for them to terminate. It will retry any failed Pods until a specified number have exited successfully. The Job’s then marked as complete.Jobs provide a mechanism for running ad-hoc tasks inside your cluster. Kubernetes also provides CronJobs that wrap Jobs with cron-like scheduling support. These let you automatically run a job on a regular cadence to accommodate batch activities, backups, and any other scheduled tasks your application requires.
</summary>

```bash
# List all jobs in the cluster.
kubectl get jobs 

# Get detailed information about a job.
kubectl describe job <job-name>

# Create a new job.
kubectl create job <job-name> 

# Delete a job.
kubectl delete job <job-name> 
```
</details>

<details>
<summary>
<b>CronJobs</b>
</summary>

```bash
# List all cron jobs in the cluster.
kubectl get cronjobs 

# Get detailed information about a cron job.
kubectl describe cronjob <cronjob-name> 

# Create a new cron job.
kubectl create cronjob <cronjob-name> 

# Delete a cron job.
kubectl delete cronjob <cronjob-name> 
```
</details>


<details>
<summary>
<b>Configmaps</b>
- ConfigMaps are a similar concept for non-sensitive information. These objects should store any general settings your app requires. They can be supplied to Pods as environment variables or files mounted into a volume.
</summary>

```bash
# List all config maps in the cluster.
kubectl get configmaps 

# Get detailed information about a config map.
kubectl describe configmap <configmap-name> 

# Create a new config map.
kubectl create configmap <configmap-name> 

# Delete a config map.
kubectl delete configmap <configmap-name> 
```
</details>

<details>
<summary>
<b>Secrets</b>
- Secrets are used to inject sensitive data into your cluster such as API keys, certificates, and other kinds of credential. They can be supplied to Pods as environment variables or files mounted into a volume.
</summary>

```bash
# List all secrets in the cluster.
kubectl get secrets 

# Get detailed information about a secret.
kubectl describe secret <secret-name> 

# Create a new secret.
kubectl create secret <secret-name> 

# Delete a secret.
kubectl delete secret <secret-name> 
```
</details>

<details>
<summary>
<b>Ingresses</b>
- Ingresses are closely related objects. These are used to set up HTTP routes to services via a load balancer. Ingresses also support HTTPS traffic secured by TLS certificates.
</summary>

```bash
# List all ingresses in the cluster.
kubectl get ingresses 

# Get detailed information about an ingress.
kubectl describe ingress <ingress-name>

# Create a new ingress.
kubectl create ingress <ingress-name> 

# Delete an ingress.
kubectl delete ingress <ingress-name> 
```
</details>

<details>
<summary>
<b>PersistentVolumes</b>
</summary>

```bash
# List all persistent volumes in the cluster.
kubectl get pv 

# Get detailed information about a persistent volume.
kubectl describe pv <persistentvolume-name> 

# Create a new persistent volume.
kubectl create pv <persistentvolume-name> 

# Delete a persistent volume.
kubectl delete pv <persistentvolume-name> 
```
</details>

<details>
<summary>
<b>PersistentVolumesClaims</b>
</summary>

```bash
# List all persistent volumes in the cluster.
kubectl get pvc

# Get detailed information about a persistent volume.
kubectl describe pvc <persistentvolumesclaim-name> 

# Create a new persistent volume.
kubectl create pvc <persistentvolumesclaim-name> 

# Delete a persistent volume.
kubectl delete pvc <persistentvolumesclaim-name> 
```
</details>


## References

- [Kubernetes Concept](https://kubernetes.io/docs/concepts/)
- [Kubernetes Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)